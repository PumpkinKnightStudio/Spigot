From e4549f3dcd816a3704373d57a16b92037c200832 Mon Sep 17 00:00:00 2001
From: BuildTools <unconfigured@null.spigotmc.org>
Date: Tue, 5 Apr 2016 02:34:27 +0200
Subject: [PATCH] Anti Xray


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 3c67d36..0c7cd6a 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -116,7 +116,7 @@ public class Chunk {
                         int j1 = i1 >> 4;
 
                         if (this.sections[j1] == Chunk.a) {
-                            this.sections[j1] = new ChunkSection(j1 << 4, flag);
+                            this.sections[j1] = new ChunkSection(j1 << 4, flag, world.spigotConfig.antiXrayInstance.getPredefinedBlockData(this, j1)); // Spigot - add blocks used for obfuscation to the DataPalette
                         }
 
                         this.sections[j1].setType(k, i1 & 15, l, iblockdata);
@@ -458,7 +458,7 @@ public class Chunk {
                     return null;
                 }
 
-                chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m());
+                chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(), this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(this, j >> 4)); // Spigot - add blocks used for obfuscation to the DataPalette
                 flag = j >= i1;
             }
 
@@ -541,7 +541,7 @@ public class Chunk {
         ChunkSection chunksection = this.sections[k >> 4];
 
         if (chunksection == Chunk.a) {
-            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m());
+            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(), this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(this, k >> 4)); // Spigot - add blocks used for obfuscation to the DataPalette
             this.initLighting();
         }
 
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 5d77c92..41cc399 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -323,7 +323,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         for (int k = 0; k < nbttaglist.size(); ++k) {
             NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
             byte b1 = nbttagcompound1.getByte("Y");
-            ChunkSection chunksection = new ChunkSection(b1 << 4, flag);
+            ChunkSection chunksection = new ChunkSection(b1 << 4, flag, world.spigotConfig.antiXrayInstance.getPredefinedBlockData(chunk, b1)); // Spigot - add blocks used for obfuscation to the DataPalette
             byte[] abyte = nbttagcompound1.getByteArray("Blocks");
             NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
             NibbleArray nibblearray1 = nbttagcompound1.hasKeyOfType("Add", 7) ? new NibbleArray(nbttagcompound1.getByteArray("Add")) : null;
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 6cf71b8..1fc6f0b 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -9,9 +9,9 @@ public class ChunkSection {
     private NibbleArray emittedLight;
     private NibbleArray skyLight;
 
-    public ChunkSection(int i, boolean flag) {
+    public ChunkSection(int i, boolean flag, IBlockData[] predefinedBlockData) { // Spigot - blocks used for obfuscation
         this.yPos = i;
-        this.blockIds = new DataPaletteBlock();
+        this.blockIds = new DataPaletteBlock(predefinedBlockData); // Spigot - add blocks used for obfuscation to the DataPalette
         this.emittedLight = new NibbleArray();
         if (flag) {
             this.skyLight = new NibbleArray();
@@ -20,9 +20,9 @@ public class ChunkSection {
     }
 
     // CraftBukkit start
-    public ChunkSection(int y, boolean flag, char[] blockIds) {
+    public ChunkSection(int y, boolean flag, char[] blockIds, IBlockData[] predefinedBlockData) { // Spigot - blocks used for obfuscation
         this.yPos = y;
-        this.blockIds = new DataPaletteBlock();
+        this.blockIds = new DataPaletteBlock(predefinedBlockData); // Spigot - add blocks used for obfuscation to the DataPalette
         for (int i = 0; i < blockIds.length; i++) {
             int xx = i & 15;
             int yy = (i >> 8) & 15;
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
index f3a6799..85423c1 100644
--- a/src/main/java/net/minecraft/server/DataBits.java
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -35,6 +35,27 @@ public class DataBits {
 
     }
 
+    // Spigot start
+    public long obfuscate(int blockIndex, int bits, long data) { // Spigot - first part of void a(int paramInt1, int paramInt2), doesn't modify this.a but the data-paramater and returns it
+        int j1 = (blockIndex * this.b) % 64;
+        return data & ~(this.c << j1) | ((long) bits & this.c) << j1;
+    }
+
+    public long obfuscateSplittedPart(int blockIndex, int bits, long data) { // Spigot - second part of void a(int paramInt1, int paramInt2), doesn't modify this.a but the data-paramater and returns it
+        int k1 = 64 - (blockIndex * this.b) % 64;
+        int l1 = this.b - k1;
+        return data >>> l1 << l1 | ((long) bits & this.c) >> k1;
+    }
+
+    public int getArrayIndex(int blockIndex) { // Spigot - returns the array index of this.a for the blockIndex
+        return (blockIndex * this.b) / 64;
+    }
+
+    public boolean isSplitted(int blockIndex) { // Spigot - returns true if and only if the block is splitted over two array indexes
+        return getArrayIndex(blockIndex) != ((blockIndex + 1) * this.b - 1) / 64;
+    }
+    // Spigot end
+
     public int a(int i) {
         Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
         int j = i * this.b;
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index e29298e..549de62 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -7,11 +7,40 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     protected DataBits b;
     protected DataPalette c;
     private int e = 0;
+    // Spigot start
+    private final IBlockData[] predefinedBlockData; // Spigot - blocks used for obfuscation
+    private final int[] currentPredefinedBlockData; // Spigot - blocks used for obfuscation
 
-    public DataPaletteBlock() {
+    /*public DataPaletteBlock() { // Spigot - use other constructor instead
         this.b(4);
+    }*/
+
+    public DataPaletteBlock(IBlockData[] predefinedBlockData) { // Spigot - add blocks used for obfuscation to the DataPalette
+        this.predefinedBlockData = predefinedBlockData;
+        if (predefinedBlockData == null) { // Spigot - default constructor
+            this.currentPredefinedBlockData = null;
+            this.b(4);
+        } else {
+            this.currentPredefinedBlockData = new int[predefinedBlockData.length];
+            int maxIndex = predefinedBlockData.length; // Spigot - count bits of the maximum array index (+1 because AIR is also added) -> array length
+            int bitCount = 0;
+            while (maxIndex != 0) {
+                maxIndex >>= 1;
+                bitCount++;
+            }
+            this.b(bitCount == 0 ? 4 : bitCount); // Spigot - initialize a DataPalette with bitCount
+        }
+    }
+
+    public IBlockData[] getPredefinedBlockData() {
+        return this.predefinedBlockData;
     }
 
+    public int[] getCurrentPredefinedBlockData() {
+        return this.currentPredefinedBlockData;
+    }
+    // Spigot end
+
     private static int b(int i, int j, int k) {
         return j << 8 | k << 4 | i;
     }
@@ -30,6 +59,15 @@ public class DataPaletteBlock implements DataPaletteExpandable {
             }
 
             this.c.a(DataPaletteBlock.a);
+
+            // Spigot start - add blocks used for obfuscation to the DataPalette
+            if (this.predefinedBlockData != null) {
+                for (int j = 0; j < this.predefinedBlockData.length; j++) {
+                    this.currentPredefinedBlockData[j] = this.c.a(this.predefinedBlockData[j]);
+                }
+            }
+            // Spigot end
+
             this.b = new DataBits(this.e, 4096);
         }
     }
@@ -65,18 +103,26 @@ public class DataPaletteBlock implements DataPaletteExpandable {
         return this.a(b(i, j, k));
     }
 
-    protected IBlockData a(int i) {
+    public IBlockData a(int i) { // Spigot - change from protected to public
         IBlockData iblockdata = this.c.a(this.b.a(i));
 
         return iblockdata == null ? DataPaletteBlock.a : iblockdata;
     }
 
-    public void b(PacketDataSerializer packetdataserializer) {
+    // Spigot start
+    public void serialize(PacketDataSerializer packetdataserializer, Chunk chunk, ChunkSection chunksection) { // Spigot - use this instead of b
         packetdataserializer.writeByte(this.e);
         this.c.b(packetdataserializer);
-        packetdataserializer.a(this.b.a());
+        chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk, chunksection, this, this.b, packetdataserializer); // Spigot - serialize and obfuscate DataBits
     }
 
+    /*public void b(PacketDataSerializer packetdataserializer) { // Spigot - use serialize instead
+        packetdataserializer.writeByte(this.e);
+        this.c.b(packetdataserializer);
+        packetdataserializer.a(this.b.a());
+    }*/
+    // Spigot end
+
     public NibbleArray exportData(byte[] abyte, NibbleArray nibblearray) {
         NibbleArray nibblearray1 = null;
 
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index 6573634..5ccccc3 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -68,6 +68,7 @@ public class EntityFallingBlock extends Entity {
                 blockposition = new BlockPosition(this);
                 if (this.world.getType(blockposition).getBlock() == block && !CraftEventFactory.callEntityChangeBlockEvent(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), Blocks.AIR, 0).isCancelled()) {
                     this.world.setAir(blockposition);
+                    this.world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
                 } else if (!this.world.isClientSide) {
                     this.die();
                     return;
@@ -101,6 +102,7 @@ public class EntityFallingBlock extends Entity {
                                     return;
                                 }
                                 this.world.setTypeAndData(blockposition, this.block, 3);
+                                this.world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
                                 // CraftBukkit end
                                 if (block instanceof BlockFalling) {
                                     ((BlockFalling) block).a_(this.world, blockposition);
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 69720e8..7783c54 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -220,6 +220,7 @@ public class Explosion {
                 blockposition = (BlockPosition) iterator.next();
                 IBlockData iblockdata = this.world.getType(blockposition);
                 Block block = iblockdata.getBlock();
+                this.world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
 
                 if (flag) {
                     double d0 = (double) ((float) blockposition.getX() + this.world.random.nextFloat());
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index 3f7fde2..9c96c50 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -69,7 +69,8 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
             if (chunksection != Chunk.a && (!flag || !chunksection.a()) && (i & 1 << k) != 0) {
                 j |= 1 << k;
-                chunksection.getBlocks().b(packetdataserializer);
+                //chunksection.getBlocks().b(packetdataserializer); // Spigot - use serialize instead
+                chunksection.getBlocks().serialize(packetdataserializer, chunk, chunksection); // Spigot - use this instead of b
                 packetdataserializer.writeBytes(chunksection.getEmittedLightArray().asBytes());
                 if (flag1) {
                     packetdataserializer.writeBytes(chunksection.getSkyLightArray().asBytes());
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index cef986e..a1124d5 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -201,6 +201,7 @@ public class PlayerInteractManager {
             }
 
         }
+        this.world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
     }
 
     public void a(BlockPosition blockposition) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 8299abf..7115679 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -442,6 +442,18 @@ public abstract class World implements IBlockAccess {
         return this.setTypeAndData(blockposition, iblockdata, 3);
     }
 
+    // Spigot start - notify from 1.8 for anti xray
+    public void notify(BlockPosition blockposition) {
+        for (int j = 0; j < this.u.size(); ++j) {
+            IWorldAccess access = this.u.get(j);
+            if (access instanceof WorldManager) {
+                access.a(null, blockposition, null, null, 0);
+            }
+        }
+
+    }
+    // Spigot end
+
     public void notify(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(this, blockposition, iblockdata, iblockdata1, i);
@@ -497,6 +509,7 @@ public abstract class World implements IBlockAccess {
         this.e(blockposition.up(), block);
         this.e(blockposition.north(), block);
         this.e(blockposition.south(), block);
+        spigotConfig.antiXrayInstance.updateNearbyBlocks(this, blockposition); // Spigot
     }
 
     public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
@@ -725,9 +738,16 @@ public abstract class World implements IBlockAccess {
         return this.worldProvider.n()[this.getLightLevel(blockposition)];
     }
 
-    public IBlockData getType(BlockPosition blockposition) {
+    // Spigot start
+    public IBlockData getType(BlockPosition blockposition)
+    {
+        return getType(blockposition, true);
+    }
+
+    public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
-        if (captureTreeGeneration) {
+        if (captureTreeGeneration && useCaptured) {
+    // Spigot end
             Iterator<BlockState> it = capturedBlockStates.iterator();
             while (it.hasNext()) {
                 BlockState previous = it.next();
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index aa292e3..b95869d 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -73,7 +73,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                 }
                 // Build chunk section
                 if (emptyTest != 0) {
-                    csect[sec] = new ChunkSection(sec << 4, true, section);
+                    csect[sec] = new ChunkSection(sec << 4, true, section, this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Spigot - add blocks used for obfuscation to the DataPalette
                 }
             }
         }
@@ -98,7 +98,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                         secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
                     }
                     // Build chunk section
-                    csect[sec] = new ChunkSection(sec << 4, true, secBlkID);
+                    csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Spigot - add blocks used for obfuscation to the DataPalette
                 }
             }
             else { // Else check for byte-per-block section data
@@ -120,7 +120,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                             Block b = Block.getById(btypes[sec][i] & 0xFF);
                             secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
                         }
-                        csect[sec] = new ChunkSection(sec << 4, true, secBlkID);
+                        csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Spigot - add blocks used for obfuscation to the DataPalette
                     }
                 }
                 else { // Else, fall back to pre 1.2 method
@@ -160,7 +160,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                         }
                         // If section built, finish prepping its state
                         if (csbytes != null) {
-                            ChunkSection cs = csect[sec] = new ChunkSection(sec << 4, true, csbytes);
+                            ChunkSection cs = csect[sec] = new ChunkSection(sec << 4, true, csbytes, this.world.spigotConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Spigot - add blocks used for obfuscation to the DataPalette
                             cs.recalcBlockCounts();
                         }
                     }
diff --git a/src/main/java/org/spigotmc/AntiXray.java b/src/main/java/org/spigotmc/AntiXray.java
new file mode 100644
index 0000000..c5cece4
--- /dev/null
+++ b/src/main/java/org/spigotmc/AntiXray.java
@@ -0,0 +1,271 @@
+package org.spigotmc;
+
+import java.util.HashSet;
+import java.util.Set;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.DataBits;
+import net.minecraft.server.DataPaletteBlock;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.World;
+
+public class AntiXray
+{
+
+    private static final CustomTimingsHandler update = new CustomTimingsHandler("xray - update");
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler("xray - obfuscate");
+    /*========================================================================*/
+    // Used to keep track of which blocks to obfuscate
+    private final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
+    // Used to select a random replacement ore
+    private final IBlockData[] replacementOres;
+
+    public AntiXray(SpigotWorldConfig config)
+    {
+        // Set all listed blocks as true to be obfuscated
+        for (Object id : (config.engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks)
+        {
+            Block block = Block.getByName(String.valueOf(id));
+            if (block != null)
+            {
+                int intId = Block.getId(block);
+                obfuscateBlocks[intId] = true;
+            }
+        }
+        // For every block
+        Set<IBlockData> replacementOreList = new HashSet<IBlockData>();
+        for (Object id : config.hiddenBlocks)
+        {
+            Block block = Block.getByName(String.valueOf(id));
+            // Check it exists and is not a tile entity
+            if (block != null && !block.isTileEntity())
+            {
+                // Add it to the list of replacement blocks
+                replacementOreList.add(block.getBlockData());
+            }
+        }
+        replacementOres = replacementOreList.toArray(new IBlockData[replacementOreList.size()]);
+    }
+
+    /**
+     * Returns the replacement blocks for a ChunkSection.
+     * Used when a ChunkSection is created.
+     */
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY)
+    {
+        if (chunk.world.spigotConfig.antiXray && chunkY <= chunk.world.spigotConfig.maxChunkY)
+        {
+            switch (chunk.world.spigotConfig.engineMode)
+            {
+                case 1:
+                    switch (chunk.world.getWorld().getEnvironment())
+                    {
+                        case NETHER:
+                            return new IBlockData[] {Blocks.NETHERRACK.getBlockData()};
+                        case THE_END:
+                            return new IBlockData[] {Blocks.END_STONE.getBlockData()};
+                        default:
+                            return new IBlockData[] {Blocks.STONE.getBlockData()};
+                    }
+                case 2:
+                case 3:
+                    return replacementOres;
+            }
+        }
+        
+        return null;
+    }
+
+    /**
+     * Starts the timings handler, then updates all blocks within the set radius
+     * of the given coordinate, revealing them if they are hidden ores.
+     */
+    public void updateNearbyBlocks(World world, BlockPosition position)
+    {
+        if (world.spigotConfig.antiXray)
+        {
+            update.startTiming();
+            updateNearbyBlocks(world, position, 2, false); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+            update.stopTiming();
+        }
+    }
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    public void obfuscateSync(Chunk chunk, ChunkSection chunkSection, DataPaletteBlock dataPaletteBlock, DataBits dataBits, PacketDataSerializer packetDataSerializer)
+    {
+        if (chunk.world.spigotConfig.antiXray && (chunkSection.getYPosition() >> 4) <= chunk.world.spigotConfig.maxChunkY && dataPaletteBlock.getCurrentPredefinedBlockData() != null && dataPaletteBlock.getCurrentPredefinedBlockData().length > 0)
+        {
+            obfuscate.startTiming();
+            obfuscate(chunk, chunkSection, dataPaletteBlock, dataBits, packetDataSerializer);
+            obfuscate.stopTiming();
+        }
+        else
+        {
+            packetDataSerializer.a(dataBits.a());
+        }
+    }
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    public void obfuscate(Chunk chunk, ChunkSection chunkSection, DataPaletteBlock dataPaletteBlock, DataBits dataBits, PacketDataSerializer packetDataSerializer)
+    {   
+        // Initial radius to search around for air
+        int initialRadius = 1;
+        // The iterator marking which random ore we should use next
+        int randomOre = 0;
+        // Chunk corner X and Z blocks
+        int startX = chunk.locX << 4;
+        int startZ = chunk.locZ << 4;
+        // Boolean used to check if the engine mode is 3 (used for the initial value of x in the inner loop)
+        boolean engineMode3 = chunk.world.spigotConfig.engineMode == 3;
+        // Increment the inner loop by 3 in engine mode 3 for more efficiency
+        int increment = engineMode3 ? 3 : 1;
+        // Stores the last dataBits-array-index which was obfuscated
+        int dataBitsIndex = 0;
+        // Stores the last data which was obfuscated but not written to the packet
+        long currentData = dataBits.a()[0];
+        // Write the length of the dataBits-array to the packet as it is in vanilla
+        packetDataSerializer.d(dataBits.a().length);
+        // Write the dataBits-array to the packet
+        // Work through all blocks in the chunkSection
+        for (int y = 0; y < 16; y++)
+        {
+            for (int z = 0; z < 16; z++)
+            {
+                // Shift the initial value of x and increment by 3 in engine mode 3
+                for (int x = engineMode3 ? (((chunk.locX + chunk.locZ + (chunkSection.getYPosition() >> 4) + y + z) % 3 + 3) % 3) : 0; x < 16; x += increment)
+                {
+                    // Calculate the blockIndex from y, z, x and get the blockData from dataPaletteBlock
+                    // More efficient because we may use the blockIndex again later
+                    int blockIndex = y << 8 | z << 4 | x;
+                    IBlockData blockData = dataPaletteBlock.a(blockIndex);
+                    // Check if the block should be obfuscated
+                    if (obfuscateBlocks[Block.getId(blockData.getBlock())])
+                    {
+                        BlockPosition position = new BlockPosition(startX + x, chunkSection.getYPosition() + y, startZ + z);
+                        // Check if the nearby blocks are loaded (edge blocks)
+                        if (!isLoaded(chunk.world, position, initialRadius))
+                        {
+                            continue;
+                        }
+                        // Check if the nearby blocks are not transparent, we can obfuscate
+                        if (!hasTransparentBlockAdjacent(chunk.world, position, initialRadius))
+                        {
+                            // Get one of the predefined blocks which can be used for obfuscation
+                            if (randomOre >= dataPaletteBlock.getCurrentPredefinedBlockData().length)
+                            {
+                                randomOre = 0;
+                            }
+                            int newBlockData = dataPaletteBlock.getCurrentPredefinedBlockData()[randomOre++];
+                            // Get the current dataBits-array-index for the block index
+                            int currentDataBitsIndex = dataBits.getArrayIndex(blockIndex);
+                            // Check if it has been changed
+                            if (currentDataBitsIndex != dataBitsIndex)
+                            {
+                                // If so, we can write the last obfuscated data to the packet because it is finished with the obfuscation
+                                packetDataSerializer.writeLong(currentData);
+                                dataBitsIndex++;
+                                // We can also write all further content of the dataBits-array to the packet (until currentDataBitsIndex is reached)
+                                // because they didn't change
+                                while (dataBitsIndex < currentDataBitsIndex) {
+                                    packetDataSerializer.writeLong(dataBits.a()[dataBitsIndex]);
+                                    dataBitsIndex++;
+                                }
+                                // Now we get the data which has to be obfuscated
+                                currentData = dataBits.a()[dataBitsIndex];
+                            }
+                            // Obfuscate currentData
+                            currentData = dataBits.obfuscate(blockIndex, newBlockData, currentData);
+                            // Check if the data of the current block is spitted to the next dataBits-array-index
+                            if (dataBits.isSplitted(blockIndex)) {
+                                // If so, we can write currentData to the packet because it is finished with the obfuscation
+                                packetDataSerializer.writeLong(currentData);
+                                dataBitsIndex++;
+                                // Get the data at the next index
+                                currentData = dataBits.a()[dataBitsIndex];
+                                // And obfuscate it
+                                currentData = dataBits.obfuscateSplittedPart(blockIndex, newBlockData, currentData);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // Write the rest of the dataBits-array to the packet
+        packetDataSerializer.writeLong(currentData);
+        dataBitsIndex++;
+        while (dataBitsIndex < dataBits.a().length)
+        {
+            packetDataSerializer.writeLong(dataBits.a()[dataBitsIndex]);
+            dataBitsIndex++;
+        }
+    }
+
+    private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf)
+    {
+        // If the block in question is loaded
+        if (world.isLoaded(position))
+        {
+            // Get block id
+            Block block = world.getType(position).getBlock();
+            // See if it needs update
+            if (updateSelf && obfuscateBlocks[Block.getId(block)])
+            {
+                // Send the update
+                world.notify(position);
+            }
+            // Check other blocks for updates
+            if (radius > 0)
+            {
+                updateNearbyBlocks(world, position.east(), radius - 1, true);
+                updateNearbyBlocks(world, position.west(), radius - 1, true);
+                updateNearbyBlocks(world, position.up(), radius - 1, true);
+                updateNearbyBlocks(world, position.down(), radius - 1, true);
+                updateNearbyBlocks(world, position.south(), radius - 1, true);
+                updateNearbyBlocks(world, position.north(), radius - 1, true);
+            }
+        }
+    }
+
+    private static boolean isLoaded(World world, BlockPosition position, int radius)
+    {
+        return world.isLoaded(position)
+                && (radius == 0 ||
+                (isLoaded(world, position.east(), radius - 1)
+                && isLoaded(world, position.west(), radius - 1)
+                && isLoaded(world, position.up(), radius - 1)
+                && isLoaded(world, position.down(), radius - 1)
+                && isLoaded(world, position.south(), radius - 1)
+                && isLoaded(world, position.north(), radius - 1)));
+    }
+
+    private static boolean hasTransparentBlockAdjacent(World world, BlockPosition position, int radius)
+    {
+        return !isSolidBlock(world.getType(position, false).getBlock()) /* isSolidBlock */
+                || (radius > 0
+                && (hasTransparentBlockAdjacent(world, position.east(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.west(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.up(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.down(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.south(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.north(), radius - 1)));
+    }
+
+    private static boolean isSolidBlock(Block block)
+    {
+        // Mob spawners are treated as solid blocks as far as the
+        // game is concerned for lighting and other tasks but for
+        // rendering they can be seen through therefor we special
+        // case them so that the antixray doesn't show the fake
+        // blocks around them.
+        return block.isOccluding(block.getBlockData()) && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 374dc38..2c3b235 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -69,8 +69,8 @@ public class SpigotConfig
 
         commands = new HashMap<String, Command>();
 
-        version = getInt( "config-version", 8 );
-        set( "config-version", 8 );
+        version = getInt( "config-version", 9 );
+        set( "config-version", 9 );
         readConfig( SpigotConfig.class, null );
     }
 
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 43242a8..d2bfa67 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -1,5 +1,6 @@
 package org.spigotmc;
 
+import java.util.Arrays;
 import java.util.List;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -204,6 +205,48 @@ public class SpigotWorldConfig
         log( "Arrow Despawn Rate: " + arrowDespawnRate );
     }
 
+    public boolean antiXray;
+    public int engineMode;
+    public List<Object> hiddenBlocks;
+    public List<Object> replaceBlocks;
+    public int maxChunkY;
+    public AntiXray antiXrayInstance;
+    private void antiXray()
+    {
+        if ( SpigotConfig.version < 9 )
+        {
+            set( "anti-xray.enabled", false );
+            set( "anti-xray.hide-blocks", null );
+            set( "anti-xray.replace-blocks", null );
+        }
+        antiXray = getBoolean( "anti-xray.enabled", false );
+        log( "Anti X-Ray: " + antiXray );
+
+        engineMode = getInt( "anti-xray.engine-mode", 3 );
+        log( "\tEngine Mode: " + engineMode );
+
+        if ( SpigotConfig.version < 5 )
+        {
+            set( "anti-xray.blocks", null );
+        }
+        hiddenBlocks = getList( "anti-xray.hide-blocks", Arrays.asList( new Object[]
+        {
+            "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone", "obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore", "ender_chest"
+        } ) );
+        log( "\tHidden Blocks: " + hiddenBlocks );
+
+        replaceBlocks = getList( "anti-xray.replace-blocks", Arrays.asList( new Object[]
+        {
+            "stone", "planks"
+        } ) );
+        log( "\tReplace Blocks: " + replaceBlocks );
+
+        maxChunkY = getInt( "anti-xray.max-chunk-y", 3 );
+        log( "\tMax Chunk Y: " + maxChunkY );
+
+        antiXrayInstance = new AntiXray( this );
+    }
+
     public boolean zombieAggressiveTowardsVillager;
     private void zombieAggressiveTowardsVillager()
     {
-- 
1.9.4.msysgit.2

